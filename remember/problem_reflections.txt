Halloween Array (codechef 164)

For this problem https://www.codechef.com/problems/SPC2025Q5 I failed because 
I avoided double for loops purely based on the input size. 
This makes sense when the worst case really amounts to going through both loops 
(O(n^2))completely but in this specific case, the extra check for duplicates 
combined with some considerations about how fast the product grows (at least n! 
if all numbers must be different and there are n of them) made it so that the 
worst case was actually much better as r is guaranteed to be 10^9 at most. 

So the main thing to take away is that when it seems like the most naive solution 
is too slow and I can't think of a better one, I should just try the naive one first
and really mentally probe the worst case scenario to see if it is actually that bad.
*/

Black cells (practice, greedy)

Although I realised n was small, the practice of double for loops just seems
to be very remote in my idea space. Deques are actually very useful especially 
for problems with small n and when i need to modify a sequence in different places
repreatedly. When I repeatedly want to insert and erase, it is smart to think
about where to best initialise it to avoid unnecessary complexity. 

If something doesnt work for a while always pause and rethink from the start if there
is a simpler way to do it. 

*/

shohag loves xor (practice, math)
Basically, the key obervation I did not get to is that if y >= 2x, then x xor y
cant be a divisor of y. This is because the highest bit of x xor y is the same as
that of x, see below.

THOUGHT: Here ğ‘¥>0
and ğ‘¦>0. So ğ‘¥âŠ•ğ‘¦ is neither equal to ğ‘¥ nor ğ‘¦. So ğ‘¥âŠ•ğ‘¦ is a divisor of ğ‘¥ or ğ‘¦ and ğ‘¥âŠ•ğ‘¦<ğ‘¥ or ğ‘¥âŠ•ğ‘¦<ğ‘¦.

OBSERVATION: Any divisor ğ‘‘
of ğ‘ such that ğ‘‘<ğ‘ we know that ğ‘‘â‰¤âŒŠğ‘2âŒ‹.

Also, the highest bits of ğ‘‘
and ğ‘ are different when ğ‘‘â‰¤âŒŠğ‘2âŒ‹.

THOUGHT: Wait but ğ‘¥âŠ•ğ‘¦
has the same highest bit as ğ‘¦ if ğ‘¦â‰¥2â‹…ğ‘¥.

CONCLUSION: So if ğ‘¦â‰¥2â‹…ğ‘¥, then ğ‘¥âŠ•ğ‘¦ can not be a divisor of ğ‘¦.
THOUGHT: But can it be a divisor of ğ‘¥?

OBSERVATION: If ğ‘¦â‰¥2â‹…ğ‘¥
, then ğ‘¥âŠ•ğ‘¦>ğ‘¥ because the highest bit in ğ‘¥âŠ•ğ‘¦ is greater than that in ğ‘¥. So ğ‘¥âŠ•ğ‘¦ can not be a divisor of ğ‘¥
CONCLUSION: If ğ‘¦â‰¥2â‹…ğ‘¥ , then ğ‘¥âŠ•ğ‘¦ can not be a divisor of ğ‘¥ or ğ‘¦

So no solution in this case.

THOUGHT: Now we need to consider the case when ğ‘¦<2â‹…ğ‘¥
. But ğ‘¥ is small in this problem, making it feasible to iterate over all possible values of ğ‘¦


ACTION: Iterate over all possible values of ğ‘¦<2â‹…ğ‘¥
and check if ğ‘¥âŠ•ğ‘¦ is a divisor of either ğ‘¥ or ğ‘¦
anjisBinaryTree (practice, trees, dfs)

"If the current node has no children, it's already a leaf, so no operations are needed."

"If it has a left child, find out the minimum operations needed to reach a leaf through the 
left subtree. Add 1 if I need to change this node's label to 'L'."

"If it has a right child, do the same for the right subtree, adding 1 if needed to change the 
label to 'R'."

"Return the smaller result of the two paths."